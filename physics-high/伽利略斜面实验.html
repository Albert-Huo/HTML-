<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>ä¼½åˆ©ç•¥çš„ç†æƒ³æ–œé¢å®éªŒ</title>
<style>
  :root{
    --card-bg: rgba(255,255,255,0.08);
    --accent:#3ddc97; --warn:#ffb74d; --error:#ff6b6b; --ink:#e9f2ff;
  }
  body{ background:#1a1a1a; color:#fff; font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Arial,Helvetica,sans-serif; margin:0; padding:10px; display:flex; flex-direction:column; align-items:center; overflow-x: hidden;}

  /* é¡¶éƒ¨å½©å¸¦ */
  #spectrum{
    position: relative; width: 100%; max-width: 900px; height: 40px; border-radius: 10px; overflow: hidden;
    box-shadow: 0 0 15px rgba(255,255,255,0.2); background: transparent; margin: 12px 0 8px; flex-shrink: 0;
  }
  #spectrum::before{
    content: ""; position: absolute; inset: 0; border-radius: inherit;
    background: linear-gradient(90deg,#ff0000 0%,#ffff00 16.66%,#00ff00 33.33%,#00ffff 50%,#0000ff 66.66%,#ff00ff 83.33%,#ff0000 100%);
    animation: hueSpin 20s linear infinite;
  }
  @keyframes hueSpin{ from{filter:hue-rotate(0deg)} to{filter:hue-rotate(360deg)} }

  /* ä»»åŠ¡å¡ç‰‡ */
  .task-card{ width:100%; max-width:900px; background:var(--card-bg); border:1px solid rgba(255,255,255,0.12); border-radius:12px; padding:12px 14px; backdrop-filter:blur(6px);
    display:grid; grid-template-columns:auto 1fr auto; gap:10px; align-items:center; transition:opacity .2s, filter .2s; margin-bottom: 10px; flex-shrink: 0;}
  .task-step{ background:rgba(255,255,255,0.15); border-radius:8px; padding:6px 10px; font-weight:600; white-space:nowrap; }
  .task-text{ line-height:1.55; } .task-hint{ color:#ffd54f; font-size:12px; opacity:.9; }
  .progress-dots{ display:flex; gap:6px; align-items:center; }
  .dot{ width:10px; height:10px; border-radius:50%; background:rgba(255,255,255,0.25); outline:2px solid rgba(255,255,255,0.15); }
  .dot.active{ background:var(--warn);} .dot.done{ background:var(--accent); outline-color:rgba(61,220,151,0.5);}

  /* ç”»å¸ƒåŒºåŸŸ */
  #canvasWrap{ 
    width:100%; max-width:900px; 
    height: 55vh; min-height: 300px; max-height: 600px;
    position:relative; overflow: hidden; border-radius:12px; 
    box-shadow:0 8px 24px rgba(0,0,0,.3);
    background: #000;
  }
  canvas{ width:100%; height:100%; display:block; touch-action:none; }

  /* å®éªŒæ§åˆ¶å±‚ - å³ä¸Šè§’ */
  .controls-overlay {
    position: absolute; top: 12px; right: 12px; 
    display: flex; flex-direction: column; gap: 8px; 
    align-items: flex-end; z-index: 10;
  }
  .control-group {
    background: rgba(15,15,15,0.85); 
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px; padding: 8px 12px; 
    backdrop-filter: blur(4px);
    display: flex; flex-direction: column; gap: 4px; 
    width: 160px;
  }
  .control-group label { font-size: 12px; color: #bbb; display: flex; justify-content: space-between;}
  .control-group input[type=range] { width: 100%; cursor: pointer; accent-color: var(--accent); margin: 4px 0 0;}
  
  /* æŒ‰é’®æ ·å¼ */
  #runBtn { 
    height: 40px; width: 160px;
    font-weight: bold; font-size: 14px; border:none; border-radius: 6px;
    background: var(--accent); color: #082415; 
    box-shadow: 0 4px 12px rgba(61,220,151,0.3); 
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; transition: all 0.2s; user-select: none;
  }
  #runBtn:active { transform: scale(0.96); }
  #runBtn.reset-mode { background: #ffb74d; color: #3e2700; box-shadow: 0 4px 12px rgba(255,183,77,0.3); }

  /* åº•éƒ¨æŒ‰é’®æ  */
  .toolbar{ width:100%; max-width:900px; margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
  .toolbar button{ padding:10px 16px; background:#444; color:#fff; border:none; border-radius:8px; cursor:pointer; transition:background .25s; user-select:none;}
  .toolbar button:hover{ background:#5a5a5a;} 
  .toolbar button:disabled{ opacity:.5; cursor:not-allowed;}

  /* HUD & Feedback */
  .hud-label {
    position: absolute; color: rgba(255,255,255,0.9); font-size: 14px; pointer-events: none;
    transition: opacity 0.3s; background: rgba(0,50,0,0.6); padding: 4px 10px; border-radius: 99px;
    border: 1px solid var(--accent);
  }
  
  .checkmark{ position:absolute; z-index:50; left:50%; top:40%; transform:translate(-50%,-50%) scale(.6); width:120px; height:120px; border-radius:50%; background:rgba(61,220,151,.15);
    border:3px solid var(--accent); display:none; align-items:center; justify-content:center; box-shadow:0 0 40px rgba(61,220,151,.45), inset 0 0 20px rgba(61,220,151,.25); animation:pop .55s ease-out;}
  .checkmark.active{ display:flex;} .checkmark>div{ width:60px; height:30px; border-left:8px solid var(--accent); border-bottom:8px solid var(--accent); transform:rotate(-45deg) translateY(-6px); }
  @keyframes pop{ 0%{transform:translate(-50%,-50%) scale(.4);opacity:.2}60%{transform:translate(-50%,-50%) scale(1.08);opacity:1}100%{transform:translate(-50%,-50%) scale(1)} }

  .toast{ position:fixed; left:50%; bottom:24px; transform:translateX(-50%) translateY(20px); background:rgba(0,0,0,0.8); color:#fff; padding:10px 14px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,.35);
    font-size:14px; opacity:0; pointer-events:none; transition:opacity .25s, transform .25s; z-index:200;}
  .toast.show{ opacity:1; transform:translateX(-50%) translateY(0); }

  .modal-mask{ position:fixed; inset:0; background:rgba(0,0,0,0.5); display:none; align-items:center; justify-content:center; z-index:300; }
  .modal{ width:min(90vw,360px); background:#111; color:#fff; border:1px solid rgba(255,255,255,.15); border-radius:14px; padding:18px 16px; text-align:center; box-shadow:0 10px 30px rgba(0,0,0,.5);}
  .modal h3{ margin:8px 0 6px; font-size:20px;} .modal p{ color:#cfd8dc; margin-top:0;} .modal .ok{ margin-top:12px; background:var(--accent); color:#081a12; font-weight:700; border:none; padding:10px 20px; border-radius:6px; cursor:pointer;}

  .explanation{ width:100%; max-width:900px; margin:14px 0 20px; line-height:1.65; font-size:.95em; color:var(--ink);}
  .explanation h2{ margin:.2em 0 .4em; color:#9bd3ff; font-size:1.15em;} .explanation ul{ margin:.2em 0 .2em 1.1em;}
</style>
</head>
<body>
  <div id="spectrum"></div>

  <div class="task-card" id="taskCard">
    <div class="task-step" id="taskStep">æ­¥éª¤ 1 / 3</div>
    <div class="task-text">
      <div id="taskText">ä¿æŒ<strong>ç²—ç³™è¡¨é¢</strong>å’Œ<strong>é™¡å³­è§’åº¦</strong>ï¼Œé‡Šæ”¾å°çƒã€‚</div>
      <div class="task-hint" id="taskHint">æç¤ºï¼šå°†â€œæ¥è§¦é¢â€æ‹‰å¤§ï¼Œå¡åº¦>30Â°ï¼Œçœ‹çœ‹å°çƒèƒ½æ»šå¤šé«˜ï¼Ÿ</div>
    </div>
    <div class="progress-dots">
      <span class="dot active" id="dot1"></span><span class="dot" id="dot2"></span><span class="dot" id="dot3"></span>
    </div>
  </div>

  <div id="canvasWrap">
    <canvas id="simCanvas"></canvas>
    <div class="checkmark" id="checkmark"><div></div></div>
    
    <div class="controls-overlay">
      <div class="control-group">
        <label><span>æ¥è§¦é¢</span> <span id="fricVal">ç²—ç³™</span></label>
        <input type="range" id="fricSlider" min="0" max="100" value="80">
      </div>
      <div class="control-group">
        <label><span>å³ä¾§å¡åº¦</span> <span id="angleVal">45Â°</span></label>
        <input type="range" id="angleSlider" min="0" max="60" value="45">
      </div>
      <button id="runBtn">é‡Šæ”¾å°çƒ</button>
    </div>

    <div id="infiniteTag" class="hud-label" style="display:none; top:30%; left:50%; transform:translateX(-50%);">
      âˆ æ°¸æ’è¿åŠ¨ï¼ˆæƒ¯æ€§ï¼‰
    </div>
  </div>

  <div class="toolbar">
    <button id="resetStepBtn">æ­¥éª¤é‡ç½®</button>
    <button id="autoDemoBtn">è‡ªåŠ¨æ¼”ç¤º</button>
    <button id="freeBtn">è‡ªç”±æ¨¡å¼</button>
  </div>

  <div class="toast" id="toast">å†è¯•ä¸€è¯•ï¼šè¯·æŒ‰æ­¥éª¤æç¤ºè°ƒæ•´å‚æ•°</div>

  <div class="modal-mask" id="doneMask" role="dialog">
    <div class="modal">
      <h3 id="doneTitle">æ¢ç´¢å®Œæˆï¼ğŸ‰</h3>
      <p>ä¼½åˆ©ç•¥å‘ç°ï¼šå¦‚æœæ²¡æœ‰æ‘©æ“¦åŠ›ï¼Œç‰©ä½“å°†åœ¨æ°´å¹³é¢ä¸Šæ°¸è¿œè¿åŠ¨ä¸‹å»ï¼ˆç‰›é¡¿ç¬¬ä¸€å®šå¾‹ï¼‰ã€‚</p>
      <button class="ok" id="okBtn">æ˜ç™½</button>
    </div>
  </div>

  <div class="explanation">
    <h2>ä¼½åˆ©ç•¥çš„é©å‘½æ€§å‘ç°</h2>
    <ul>
      <li><strong>ç†æƒ³å®éªŒ</strong>ï¼šä¼½åˆ©ç•¥è®¾æƒ³ï¼Œå¦‚æœæ²¡æœ‰æ‘©æ“¦ï¼Œå°çƒä¸ºäº†æ»šå›åŸæ¥çš„é«˜åº¦ï¼Œä¼šä¸€ç›´è¿åŠ¨ä¸‹å»ã€‚</li>
      <li><strong>ç‰›é¡¿ç¬¬ä¸€å®šå¾‹</strong>ï¼šè¿™ä¸ºåæ¥ç‰›é¡¿æå‡ºçš„â€œæƒ¯æ€§â€æ¦‚å¿µå¥ å®šäº†åŸºç¡€ã€‚</li>
    </ul>
  </div>

<script>
// ç­‰å¾…DOMåŠ è½½ï¼Œé˜²æ­¢è„šæœ¬é”™è¯¯
document.addEventListener('DOMContentLoaded', function() {
  
  /* ------------ çŠ¶æ€ç®¡ç† ------------ */
  const state = {
    friction: 0.8, 
    angle: 45,     
    ball: { x:0, y:0, vx:0, vy:0, rolling:false, stopped:false, section:'left' }, 
    cameraX: 0,
    completed: false, // å…¨éƒ¨å®Œæˆ
    freeMode: false,
    currentTask: 0,
    autoLock: false,
    isInfinite: false,
    successPending: false // ã€é‡è¦ã€‘é˜²æ­¢é‡å¤è§¦å‘çš„é”
  };

  /* ------------ DOM å¼•ç”¨ ------------ */
  const cvs = document.getElementById('simCanvas');
  const ctx = cvs ? cvs.getContext('2d') : null;
  const fricSlider = document.getElementById('fricSlider');
  const angleSlider = document.getElementById('angleSlider');
  const fricVal = document.getElementById('fricVal');
  const angleVal = document.getElementById('angleVal');
  const runBtn = document.getElementById('runBtn');
  const resetStepBtn = document.getElementById('resetStepBtn');
  const autoBtn = document.getElementById('autoDemoBtn');
  const freeBtn = document.getElementById('freeBtn');
  const infiniteTag = document.getElementById('infiniteTag');

  const taskStepEl = document.getElementById('taskStep');
  const taskTextEl = document.getElementById('taskText');
  const taskHintEl = document.getElementById('taskHint');
  const dots = [document.getElementById('dot1'), document.getElementById('dot2'), document.getElementById('dot3')];
  
  const checkmark = document.getElementById('checkmark');
  const toast = document.getElementById('toast');
  const doneMask = document.getElementById('doneMask');
  const okBtn = document.getElementById('okBtn');

  if (!ctx) return; // å®‰å…¨æ£€æŸ¥

  /* ------------ å¸¸é‡ä¸ç‰©ç†å‚æ•° ------------ */
  let animationId;
  const PI = Math.PI;
  const G = 0.5;
  const LEFT_SLOPE_W = 200;
  const LEFT_SLOPE_H = 150;
  const FLAT_W = 300; 

  /* ------------ ä»»åŠ¡å®šä¹‰ ------------ */
  const tasks = [
    { 
      // æ­¥éª¤1ï¼šéªŒè¯æ‘©æ“¦åŠ›
      check: (s) => s.friction > 0.3 && s.angle > 30,
      text: 'ä¿æŒ<strong>ç²—ç³™è¡¨é¢</strong>å’Œ<strong>é™¡å³­è§’åº¦</strong>ï¼Œé‡Šæ”¾å°çƒã€‚',
      hint: 'æç¤ºï¼šå°†â€œæ¥è§¦é¢â€è°ƒå¤§ï¼Œå¡åº¦>30Â°ï¼Œè§‚å¯Ÿæ‘©æ“¦åŠ›é€ æˆçš„èƒ½é‡æŸè€—ã€‚',
      successMsg: 'ç”±äºæ‘©æ“¦åŠ›ï¼Œå°çƒæ— æ³•æ»šå›åŸæ¥çš„é«˜åº¦ã€‚'
    },
    { 
      // æ­¥éª¤2ï¼šéªŒè¯ç†æƒ³å…‰æ»‘
      check: (s) => s.friction < 0.01 && s.angle < 25 && s.angle > 0,
      text: 'å°†è¡¨é¢è®¾ä¸º<strong>å…‰æ»‘</strong>ï¼Œå¹¶<strong>å‡å°</strong>å³ä¾§å¡åº¦ã€‚',
      hint: 'æç¤ºï¼šæ‘©æ“¦åŠ›è°ƒä¸º0 (ç†æƒ³çŠ¶æ€)ï¼Œå¡åº¦è°ƒä½(10Â°~20Â°)ã€‚',
      successMsg: 'æ²¡æœ‰æ‘©æ“¦åŠ›ï¼Œå°çƒä¸ºäº†å›åˆ°åŸé«˜åº¦ï¼Œæ»šå¾—æ›´è¿œäº†ï¼'
    },
    { 
      // æ­¥éª¤3ï¼šæƒ¯æ€§
      check: (s) => s.friction < 0.01 && s.angle === 0,
      text: 'ç»ˆæå®éªŒï¼š<strong>å…‰æ»‘è¡¨é¢</strong> + <strong>å®Œå…¨æ°´å¹³</strong> (0Â°)ã€‚',
      hint: 'æç¤ºï¼šå°†å¡åº¦æ‹‰åˆ°åº•(0Â°)ï¼Œæ‘©æ“¦åŠ›ä¸º0ã€‚',
      successMsg: 'å› ä¸ºæ°¸è¿œæ— æ³•åˆ°è¾¾é‚£ä¸ªé«˜åº¦ï¼Œå®ƒå°†æ°¸è¿œè¿åŠ¨ä¸‹å»ï¼'
    }
  ];

  /* ------------ æ ¸å¿ƒé€»è¾‘ ------------ */

  function resetBall(){
    if(!cvs) return;
    const h = cvs.height || 300;
    
    state.ball.x = 50; 
    state.ball.y = h - 50 - LEFT_SLOPE_H;
    state.ball.vx = 0; 
    state.ball.vy = 0;
    state.ball.rolling = false;
    state.ball.stopped = false;
    state.ball.section = 'left';
    state.cameraX = 0;
    state.isInfinite = false;
    
    // ã€é‡è¦ã€‘é‡ç½®æˆåŠŸé”ï¼Œå…è®¸ä¸‹ä¸€æ¬¡æ£€æµ‹
    state.successPending = false; 

    infiniteTag.style.display = 'none';
    if(animationId) cancelAnimationFrame(animationId);
    
    updateRunBtnState('start');
    draw();
  }

  function updateRunBtnState(mode) {
    if(mode === 'reset') {
      runBtn.textContent = 'å°çƒå¤ä½';
      runBtn.classList.add('reset-mode');
    } else {
      runBtn.textContent = 'é‡Šæ”¾å°çƒ';
      runBtn.classList.remove('reset-mode');
    }
  }

  function resize(){
    const parent = cvs.parentElement;
    if(parent){
      const rect = parent.getBoundingClientRect();
      cvs.width = rect.width;
      cvs.height = rect.height;
      resetBall();
    }
  }

  /* ------------ ç‰©ç†è®¡ç®— (ä¿®æ­£ç‰ˆ) ------------ */
  function updatePhysics(){
    if(!state.ball.rolling) return;

    const groundY = cvs.height - 50;
    const startY = groundY - LEFT_SLOPE_H; 
    const flatStartX = 50 + LEFT_SLOPE_W;
    const flatEndX = flatStartX + FLAT_W;

    // 1. å·¦å¡ä¸‹è½
    if(state.ball.section === 'left'){
      const progress = (state.ball.x - 50) / LEFT_SLOPE_W;
      if(progress >= 1){
        state.ball.section = 'flat';
        state.ball.x = flatStartX;
        state.ball.y = groundY;
        // èƒ½é‡å®ˆæ’å…¬å¼ v = sqrt(2gh)
        state.ball.vx = Math.sqrt(2 * G * LEFT_SLOPE_H); 
      } else {
        state.ball.vx += 0.3; // è§†è§‰åŠ é€Ÿ
        state.ball.x += state.ball.vx;
        state.ball.y = startY + progress * LEFT_SLOPE_H;
      }
    }
    // 2. å¹³é¢è¿åŠ¨
    else if(state.ball.section === 'flat'){
      let frictionCoef = state.friction * 0.1; 
      // ã€ä¿®æ­£ã€‘å…‰æ»‘æ¨¡å¼ä¸‹å®Œå…¨æ— æ‘©æ“¦
      if(state.friction < 0.01) frictionCoef = 0;

      state.ball.vx -= frictionCoef;
      state.ball.x += state.ball.vx;
      state.ball.y = groundY; 

      // è¾¹ç•Œæ£€æµ‹
      if(state.angle === 0 && state.ball.x > flatEndX){
        if(state.friction < 0.01) state.isInfinite = true;
      } else if(state.ball.x >= flatEndX){
        state.ball.section = 'right';
        state.ball.x = flatEndX; 
      }

      if(state.ball.vx <= 0) stopBall();
    }
    // 3. å³å¡ä¸Šå‡
    else if(state.ball.section === 'right'){
      const rad = state.angle * PI / 180;
      const gForce = G * Math.sin(rad); 
      let fForce = state.friction * 0.05;
      if(state.friction < 0.01) fForce = 0;

      state.ball.vx -= (gForce + fForce);

      if(state.ball.vx <= 0){ 
        // é€Ÿåº¦å‡ä¸º0ï¼Œåœæ­¢
        stopBall(); 
      } else {
        state.ball.x += state.ball.vx * Math.cos(rad);
        state.ball.y -= state.ball.vx * Math.sin(rad);
      }
    }

    // é•œå¤´è·Ÿéš
    if(state.ball.x - state.cameraX > cvs.width * 0.5){
      state.cameraX = state.ball.x - cvs.width * 0.5;
    }
    
    // æ— é™è¿åŠ¨çŠ¶æ€ä¸‹çš„ä»»åŠ¡æ£€æµ‹
    if(state.isInfinite && state.ball.rolling && state.ball.vx > 0){
      infiniteTag.style.display = 'block';
      // åªæœ‰å½“å‰æ²¡åœ¨å¤„ç†æˆåŠŸé€»è¾‘æ—¶æ‰æ£€æµ‹
      if(!state.successPending) {
        // å»¶è¿Ÿä¸€ç‚¹æ£€æµ‹ï¼Œé¿å…åˆšè¿›å…¥æ— é™çŠ¶æ€å°±å¼¹çª—ï¼Œè§†è§‰ä¸Šä¸å¥½çœ‹
        if(!state._infiniteCheckTimer) {
            state._infiniteCheckTimer = setTimeout(() => {
                checkTaskSuccess();
                state._infiniteCheckTimer = null;
            }, 800);
        }
      }
    }
  }

  function stopBall(){
    state.ball.vx = 0;
    state.ball.rolling = false;
    state.ball.stopped = true;
    checkTaskSuccess();
  }

  /* ------------ ç»˜å›¾é€»è¾‘ (ä¿®æ­£æ°´å¹³é¢ç¼ºå¤±) ------------ */
  function draw(){
    if(!ctx) return;
    ctx.clearRect(0,0,cvs.width,cvs.height);
    
    ctx.save();
    ctx.translate(-state.cameraX, 0);

    const groundY = cvs.height - 50;
    const startX = 50;
    const flatStartX = startX + LEFT_SLOPE_W;
    const flatEndX = flatStartX + FLAT_W;

    // -- è½¨é“ç»˜åˆ¶ --
    ctx.beginPath();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // å·¦å¡
    ctx.moveTo(startX, groundY - LEFT_SLOPE_H);
    ctx.lineTo(flatStartX, groundY);
    
    // ã€ä¿®æ­£ã€‘åŠ¨æ€æ°´å¹³é¢ç»˜åˆ¶
    // è®¡ç®—è§†è§‰éœ€è¦çš„ç»˜åˆ¶ç»ˆç‚¹ï¼šè‡³å°‘ç”»åˆ° flatEndXï¼Œå¦‚æœé•œå¤´ç§»åŠ¨äº†ï¼Œç”»åˆ°å±å¹•å¤–
    const viewRight = state.cameraX + cvs.width; 
    const drawLimit = Math.max(flatEndX, viewRight + 200);

    if (state.angle > 0) {
       // æœ‰è§’åº¦ï¼šç”»åˆ°è½¬æŠ˜ç‚¹ï¼Œç„¶åç”»æ–œå¡
       ctx.lineTo(flatEndX, groundY);
       const rad = state.angle * PI / 180;
       const slopeLen = 1200; // è¶³å¤Ÿé•¿
       const endX = flatEndX + slopeLen * Math.cos(rad);
       const endY = groundY - slopeLen * Math.sin(rad);
       ctx.lineTo(endX, endY);
    } else {
       // æ— è§’åº¦ï¼ˆæ°´å¹³ï¼‰ï¼šä¸€ç›´ç”»ä¸‹å»
       ctx.lineTo(drawLimit, groundY);
    }

    // å¡«å……åœ°é¢
    const fillRightX = (state.angle > 0) ? (flatEndX + 1000) : drawLimit;
    ctx.lineTo(fillRightX, cvs.height + 200);
    ctx.lineTo(startX, cvs.height + 200);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fill();
    ctx.stroke();

    // -- é«˜åº¦è™šçº¿ --
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(61,220,151,0.4)';
    ctx.setLineDash([5,5]);
    ctx.moveTo(startX - 20, groundY - LEFT_SLOPE_H);
    // è™šçº¿ä¹Ÿè¦è·Ÿéšæ— é™å»¶ä¼¸
    const dashLimit = Math.max(flatEndX + 600, viewRight + 200);
    ctx.lineTo(dashLimit, groundY - LEFT_SLOPE_H);
    ctx.stroke();
    ctx.setLineDash([]);

    // -- å°çƒ --
    ctx.beginPath();
    ctx.fillStyle = '#ffb74d';
    ctx.shadowColor = '#ffb74d';
    ctx.shadowBlur = 12;
    ctx.arc(state.ball.x, state.ball.y - 10, 10, 0, PI*2); 
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.restore();

    if(state.ball.rolling){
      updatePhysics();
      animationId = requestAnimationFrame(draw);
    }
  }

  /* ------------ æ ¸å¿ƒï¼šä»»åŠ¡æ£€æµ‹ (é˜²Script Errorç‰ˆ) ------------ */
  function checkTaskSuccess(){
    // 1. å¦‚æœè‡ªç”±æ¨¡å¼ã€å·²å…¨éƒ¨å®Œæˆã€æˆ–æ­£åœ¨å¤„ç†æˆåŠŸåŠ¨ç”»ï¼Œç›´æ¥é€€å‡º
    if(state.freeMode || state.completed || state.successPending) return;
    
    // 2. å®‰å…¨è·å–å½“å‰ä»»åŠ¡ ã€é˜² Script Error å…³é”®ã€‘
    // å¦‚æœ currentTask ç´¢å¼•è¶…å‡ºäº†æ•°ç»„èŒƒå›´ï¼Œè¯´æ˜å·²ç»ç»“æŸäº†ï¼Œç›´æ¥é€€å‡º
    if(state.currentTask >= tasks.length) return;

    const task = tasks[state.currentTask];
    
    // 3. æ£€æŸ¥æ¡ä»¶
    if(task && task.check(state)){
      // é”å®šçŠ¶æ€ï¼Œé˜²æ­¢é‡å¤è§¦å‘
      state.successPending = true; 
      
      showCheck();
      showToast(task.successMsg); 
      
      // å»¶è¿Ÿåˆ‡æ¢
      setTimeout(()=>{
        dots[state.currentTask].classList.remove('active');
        dots[state.currentTask].classList.add('done');
        state.currentTask++;
        
        if(state.currentTask >= tasks.length){
          state.completed = true;
          showDone();
        } else {
          setStepUI(state.currentTask);
          // å¦‚æœæ˜¯æ— é™æ¨¡å¼ï¼Œè‡ªåŠ¨é‡ç½®ä¸€ä¸‹çƒçš„ä½ç½®ï¼Œæ–¹ä¾¿ç”¨æˆ·å¼€å§‹ä¸‹ä¸€æ­¥
          if(state.isInfinite) {
             // ç»™äºˆä¸€ç‚¹ç¼“å†²æ—¶é—´å†é‡ç½®
             setTimeout(resetBall, 1000);
          }
        }
        // ä»»åŠ¡åˆ‡æ¢å®Œæ¯•ï¼Œè§£é™¤é” (æ³¨æ„ï¼šå¦‚æœæ˜¯ resetBall ä¼šåœ¨å†…éƒ¨è§£é™¤é”ï¼Œè¿™é‡Œæ— éœ€é‡å¤)
      }, 1800);

    } else if (!state.ball.rolling && !state.isInfinite) {
       // å¤±è´¥åé¦ˆï¼ˆåªæœ‰åœä¸‹æ—¶æ‰åé¦ˆï¼‰
       const isCrash = state.angle > 0 && state.friction > 0.1 && state.ball.section === 'flat';
       showToast(isCrash ? "æ‘©æ“¦åŠ›å¤ªå¤§ï¼Œèƒ½é‡è€—å°½ã€‚" : "è¯·æŒ‰æç¤ºè°ƒæ•´å‚æ•°å†è¯•ã€‚");
    }
  }

  /* ------------ UI é€»è¾‘ ------------ */
  function setStepUI(idx){
    if(idx >= tasks.length) return;
    state.currentTask = idx;
    dots.forEach((d,i)=>{ d.className = 'dot' + (i<idx ? ' done' : i===idx ? ' active' : ''); });
    taskStepEl.textContent = `æ­¥éª¤ ${idx+1} / ${tasks.length}`;
    taskTextEl.innerHTML   = tasks[idx].text;
    taskHintEl.textContent = tasks[idx].hint;
  }

  fricSlider.oninput = (e) => {
    const v = +e.target.value;
    state.friction = v / 100;
    if(v === 0) fricVal.textContent = 'å…‰æ»‘(ç†æƒ³)';
    else if(v < 30) fricVal.textContent = 'å…‰æ»‘';
    else if(v > 70) fricVal.textContent = 'ç²—ç³™';
    else fricVal.textContent = 'æ™®é€š';
    if(!state.ball.rolling) draw();
  };

  angleSlider.oninput = (e) => {
    const v = +e.target.value;
    state.angle = v;
    angleVal.textContent = v + 'Â°';
    if(!state.ball.rolling) draw();
  };

  runBtn.onclick = () => {
    if(state.ball.rolling || state.ball.stopped || state.isInfinite){
      resetBall();
    } else {
      state.ball.rolling = true;
      state.ball.stopped = false;
      updateRunBtnState('reset');
      draw();
    }
  };

  resetStepBtn.onclick = () => {
    if(state.autoLock) return;
    state.completed = false;
    state.currentTask = 0;
    state.isInfinite = false;
    setStepUI(0);
    fricSlider.value = 80; fricSlider.oninput({target:fricSlider});
    angleSlider.value = 45; angleSlider.oninput({target:angleSlider});
    resetBall();
    showToast("åœºæ™¯å·²é‡ç½®");
  };

  function setFreeMode(on){
    state.freeMode = on;
    freeBtn.textContent = on? 'é€€å‡ºè‡ªç”±æ¨¡å¼':'è‡ªç”±æ¨¡å¼';
    const card = document.getElementById('taskCard');
    card.style.opacity = on? .25:1; 
    card.style.filter  = on? 'grayscale(.6)':'none';
    autoBtn.disabled = on;
    resetStepBtn.disabled = on;
    // è‡ªç”±æ¨¡å¼ä¸‹ä¹Ÿè¦é‡ç½®çƒï¼Œé˜²æ­¢çŠ¶æ€é”™ä¹±
    resetBall();
  }
  freeBtn.onclick = () => setFreeMode(!state.freeMode);

  /* ------------ è‡ªåŠ¨æ¼”ç¤º ------------ */
  function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }
  async function autoDemo(){
    if(state.freeMode || state.autoLock) return;
    state.autoLock = true;
    freeBtn.disabled = true;

    try {
      // å¼ºåˆ¶é‡ç½®
      state.completed = false;
      state.currentTask = 0;
      resetBall();
      
      // Step 1
      setStepUI(0);
      fricSlider.value = 80; fricSlider.oninput({target:fricSlider});
      angleSlider.value = 45; angleSlider.oninput({target:angleSlider});
      runBtn.click(); 
      await wait(3000); // ç­‰å¾…è¿åŠ¨
      // è¿™é‡Œçš„ checkTaskSuccess ä¼šè¢«è‡ªåŠ¨è§¦å‘ï¼Œæˆ‘ä»¬åªéœ€è¦ç­‰å¾…å®ƒå®Œæˆ
      // ä½†ä¸ºäº†æ¼”ç¤ºæµç•…ï¼Œæˆ‘ä»¬æ‰‹åŠ¨ç­‰å¾…è¶³å¤Ÿçš„æ—¶é—´
      await wait(2000); 
      resetBall(); await wait(500);

      // Step 2
      setStepUI(1);
      fricSlider.value = 0; fricSlider.oninput({target:fricSlider});
      angleSlider.value = 15; angleSlider.oninput({target:angleSlider});
      runBtn.click(); 
      await wait(5000); 
      await wait(2000);
      resetBall(); await wait(500);

      // Step 3
      setStepUI(2);
      angleSlider.value = 0; angleSlider.oninput({target:angleSlider});
      runBtn.click(); 
      await wait(3000); 
      await wait(2000);
      
      state.completed = true;
      showDone();
    } finally {
      state.autoLock = false;
      freeBtn.disabled = false;
      resetBall();
    }
  }
  autoBtn.onclick = autoDemo;

  /* ------------ æç¤ºå·¥å…· ------------ */
  function showToast(msg){ 
    toast.textContent = msg; 
    toast.classList.add('show'); 
    clearTimeout(showToast.t); 
    showToast.t=setTimeout(()=>toast.classList.remove('show'),2000); 
  }
  function showCheck(){ 
    checkmark.classList.add('active'); 
    setTimeout(()=>checkmark.classList.remove('active'),520); 
  }
  function showDone(){ doneMask.style.display='flex'; } 
  okBtn.onclick=()=> doneMask.style.display='none';

  // åˆå§‹åŒ–
  window.addEventListener('resize', resize);
  resize();
});
</script>
</body>
</html>
